"""
Utilities for encapsulating bases and properties of quantum operators and super-operators
as represented by qutip.Qobj()'s.
"""

import itertools
import logging
from collections import OrderedDict, namedtuple
from itertools import product as cartesian_product

import matplotlib.pyplot as plt
import matplotlib as mpl
import numpy as np
import qutip as qt
from mpl_toolkits.mplot3d import Axes3D
from pyquil.quil import Program
from pyquil.gates import I, X
from scipy.sparse import hstack as sphstack, vstack as spvstack
from scipy.sparse.linalg import norm as spnorm

_log = logging.getLogger(__name__)

# PAULI OPS
qX = qt.sigmax()
qY = qt.sigmay()
qZ = qt.sigmaz()
qI = qt.qeye(2)

EPS = 1e-8

from matplotlib.colors import LinearSegmentedColormap
THREE_COLOR_MAP = ['#48737F', '#FFFFFF', '#D6619E']
rigetti_3_color_cm = LinearSegmentedColormap.from_list(
    "Rigetti", THREE_COLOR_MAP[::-1], N=100)

FIVE_COLOR_MAP = ['#C671A2', '#545253', '#85B5BE', '#ECE9CC', '#C671A2']
rigetti_4_color_cm = LinearSegmentedColormap.from_list(
    "Rigetti", FIVE_COLOR_MAP[::-1], N=100)


def sample_outcomes(probs, n):
    """
    For a discrete probability distribution ``probs`` with outcomes
        0, 1, ..., k-1
    draw ``n`` random samples.
    """
    dist = np.cumsum(probs)
    rs = np.random.rand(n)
    return np.array([(np.where(r < dist)[0][0]) for r in rs])


def basis_state_preps(*qubits):
    """
    Generate a sequence of programs that prepares the measurement
    basis states of some set of qubits in the order such that the qubit
    with highest index is iterated over the most quickly:
    E.g., for qubits=(0, 1), it returns the circuits::

        I_0 I_1
        I_0 X_1
        X_0 I_1
        X_0 X_1
    """
    for prep in cartesian_product([I, X], repeat=len(qubits)):
        p = Program()
        for g, q in zip(prep, qubits):
            p.inst(g(q))
        yield p


def basis_labels(n):
    """
    Generate a list of basis labels for `n` qubits, ordered from least to greatest, in big-endian
     format:

        ['00..00', '00..01', ..., '11..11']

    :param n:
    :return: A list of strings of length n that enumerate the n-qubit bitstrings
    """
    return ["".join(labels) for labels in itertools.product('01', repeat=n)]


def sample_bad_readout(program, n, assignment_probs, cxn):
    """
    Generate `n` samples of measuring all outcomes of a QUIL `program`
    assuming the assignment probabilities `assignment_probs` by simulating the
    wave function on a reference-qvm SyncConnection `cxn`

    :param pyquil.quil.Program program: The program.
    :param int n: The number of samples
    :param numpy.ndarray assignment_probs: A matrix of assignment probabilities
    :param reference_qvm.api.SyncConnection cxn: the QVM connection.
    :return:
    """
    wf = cxn.wavefunction(program)
    return sample_outcomes(assignment_probs.dot(abs(wf.amplitudes.ravel())**2), n)


def make_histogram(samples, ksup):
    """
    For a list of samples [s1, s2, ..., sN] taking on integer values from 0 to ksup-1,
    make a histogram of each integer's outcome and return it.

    :param samples: The samples.
    :param ksup: The (exclusive) upper bound
    :return: A histogram of outcomes.
    """
    return np.histogram(samples, np.arange(ksup + 1) - 0.5)[0]


def estimate_assignment_probs(bitstring_prep_histograms):
    """
    Compute the estimated assignment probability matrix for a sequence of single shot histograms
    obtained by running the programs generated by `basis_state_preps()`.

        bitstring_prep_histograms[i,j] = #number of measured outcomes j when running program i

    The assignment probability is obtained by transposing and afterwards normalizing the columns.

        p[j, i] = Probability to measure outcome j when preparing the state with program i.

    :param list|numpy.ndarray bitstring_prep_histograms: A nested list or 2d array with shape
    (d, d), where ``d = 2**nqubits`` is the dimension of the Hilbert space. The first axis varies
    over the state preparation program index, the second axis corresponds to the measured bitstring.
    :return: The assignment probability matrix.
    """
    p = np.array(bitstring_prep_histograms, dtype=float).T
    p /= p.sum(axis=0)[np.newaxis, :]
    return p


def state_histogram(state, ax, title, xlabels=None, ylabels=None):
    """
    Visualize a quantum state in some specific axes instance and set a title.

    :param qutip.Qobj state: The quantum state.
    :param matplotlib.Axes ax: The matplotlib axes.
    :param str title: The title for the plot.
    """

    matrix_histogram_complex(state,
                             limits=[0, 0.5],
                             ax=ax,
                             xlabels=xlabels,
                             ylabels=ylabels,
                             threshold=0.01)
    ax.view_init(azim=-55, elev=45)
    ax.set_title(title)


def plot_pauli_transfer_matrix(ptransfermatrix, ax, labels, title):
    """
    Visualize the Pauli Transfer Matrix of a process.

    :param numpy.ndarray ptransfermatrix: The Pauli Transfer Matrix
    :param ax: The matplotlib axes.
    :param labels: The labels for the operator basis states.
    :param title: The title for the plot
    """
    im = ax.imshow(ptransfermatrix, interpolation="nearest", cmap=rigetti_3_color_cm, vmin=-1, vmax=1)
    dim = len(labels)
    plt.colorbar(im, ax=ax)
    ax.set_xticks(xrange(dim))
    ax.set_xlabel("Input Pauli Operator", fontsize=20)
    ax.set_yticks(xrange(dim))
    ax.set_ylabel("Output Pauli Operator", fontsize=20)
    ax.set_title(title, fontsize=25)
    ax.set_xticklabels(labels, rotation=45)
    ax.set_yticklabels(labels)
    ax.grid(False)


class CRMBaseError(Exception):
    """
    Base class for errors raised when the confusion rate matrix is defective.
    """
    pass


class CRMUnnormalizedError(CRMBaseError):
    """
    Raised when a confusion rate matrix is not properly normalized.
    """
    pass


class CRMValueError(CRMBaseError):
    """
    Raised when a confusion rate matrix contains elements not contained in the interval :math`[0,1]`
    """
    pass


DiagonalPOVM = namedtuple("DiagonalPOVM", ["pi_basis", "confusion_rate_matrix", "ops"])


def make_diagonal_povm(pi_basis, confusion_rate_matrix):
    """
    Create a DiagonalPOVM from a ``pi_basis`` and the ``confusion_rate_matrix`` associated with a
    readout.

    See also the willow docs on :ref:`measurement-docs`.

    :param OperatorBasis pi_basis: An operator basis of rank-1 projection operators.
    :param numpy.ndarray confusion_rate_matrix: The matrix of detection probabilities conditional
    on a prepared qubit state.
    """

    confusion_rate_matrix = np.asarray(confusion_rate_matrix)
    if not np.allclose(confusion_rate_matrix.sum(axis=0), np.ones(confusion_rate_matrix.shape[1])):
        raise CRMUnnormalizedError("Unnormalized confusion matrix:\n{}".format(
            confusion_rate_matrix))
    if not (confusion_rate_matrix >= 0).all() or not (confusion_rate_matrix <= 1).all():
        raise CRMValueError("Confusion matrix must have values in [0, 1]:"
                                          "\n{}".format(confusion_rate_matrix))

    ops = [sum((pi_j * pjk for (pi_j, pjk) in itertools.izip(pi_basis.ops, pjs)), 0)
                for pjs in confusion_rate_matrix]
    return DiagonalPOVM(pi_basis=pi_basis, confusion_rate_matrix=confusion_rate_matrix, ops=ops)


class OperatorBasis(object):
    """
    Encapsulate a complete set of basis operators.
    """

    def __init__(self, labels_ops):
        """
        Encapsulates a set of linearly independent operators.

        :param (list|tuple) labels_ops: Sequence of tuples (label, operator) where label is a string
            and operator a qutip.Qobj operator representation.
        """
        self.ops_by_label = OrderedDict(labels_ops)
        self.labels = list(self.ops_by_label.keys())
        self.ops = list(self.ops_by_label.values())
        self.dim = len(self.ops)

        # the basis change transformation matrix from a representation in the operator basis
        # to the original basis. We enforce CSR sparse matrix representation to have efficient
        # matrix vector products.
        self.basis_transform = sphstack([qt.operator_to_vector(opj).data
                                         for opj in self.ops]).tocsr()

        self._metric = None
        self._is_orthonormal = None
        self._all_hermitian = None

    def metric(self):
        """
        Compute a matrix of Hilbert-Schmidt inner products for the basis operators.
        """
        if self._metric is None:
            _log.debug("Computing and caching operator basis metric")
            self._metric = np.matrix([[(j.dag() * k).tr() for k in self.ops] for j in self.ops])
        return self._metric

    def is_orthonormal(self):
        """
        Compute a matrix of Hilbert-Schmidt inner products for the basis operators.
        """
        if self._is_orthonormal is None:
            _log.debug("Testing and caching if operator basis is orthonormal")
            self._is_orthonormal = np.allclose(self.metric(), np.eye(self.dim))
        return self._is_orthonormal

    def all_hermitian(self):
        """
        Check if all basis operators are hermitian.
        """
        if self._all_hermitian is None:
            _log.debug("Testing and caching if all basis operator are hermitian")
            self._all_hermitian = all((is_hermitian(op) for op in self.ops))
        return self._all_hermitian

    def __iter__(self):
        """
        Iterate over tuples of (label, basis_op)
        """
        for l, op in zip(self.labels, self.ops):
            yield l, op

    def product(self, *bases):
        """
        Compute the tensor product with another basis.

        :param bases: One or more additional bases to form the product with.
        :return (OperatorBasis): The tensor product basis as an OperatorBasis object.
        """
        if len(bases) > 1:
            basis_rest = bases[0].product(*bases[1:])
        else:
            assert len(bases) == 1
            basis_rest = bases[0]

        labels_ops = [(b1l + b2l, qt.tensor(b1, b2)) for (b1l, b1), (b2l, b2) in
                      itertools.product(self, basis_rest)]

        return OperatorBasis(labels_ops)

    def __pow__(self, n):
        """
        Create the n-fold tensor product basis.

        :param (int) n: The number of identical tensor factors.
        :return (OperatorBasis): The product basis.
        """
        if not isinstance(n, int):  # pragma no coverage
            raise TypeError("Can only accept an integer number of factors")
        if n < 1:  # pragma no coverage
            raise ValueError("Need positive number of factors")
        if n == 1:
            return self

        return self.product(*([self] * (n - 1)))

    def super_basis(self):
        """
        Generate the superoperator basis in which the Choi matrix can be represented.

        The follows the definition in [Chow]_

        .. [Chow] Chow et al., 2012, https://doi.org/10.1103/PhysRevLett.109.060501

        :return (OperatorBasis): The super basis as an OperatorBasis object.
        """

        labels_ops = [(bnl + "^T (x) " + bml, qt.sprepost(bm, bn)) for (bnl, bn), (bml, bm) in
                      itertools.product(self, self)]
        return OperatorBasis(labels_ops)

    def project_op(self, op):
        """
        Project an operator onto the basis.

        :param qutip.Qobj op: The operator to project.
        :return: The projection coefficients as a numpy array.
        :rtype: scipy.sparse.csr_matrix
        """
        if not self.is_orthonormal():  # pragma no coverage
            raise ValueError("project_op only implemented for orthonormal operator bases")
        return self.basis_transform.H * qt.operator_to_vector(op).data

    def transfer_matrix(self, sop):
        """
        Compute the transfer matrix :math:`R_{jk} = \tr[P_j sop(P_k)]`.

        :param qutip.Qobj sop: The superoperator to transform.
        :return: The transfer matrix in sparse form.
        :rtype: scipy.sparse.csr_matrix
        """
        if not self.is_orthonormal():  # pragma no coverage
            raise ValueError("transfer_matrix() only implemented for orthonormal operator bases")
        return self.basis_transform.H * sop.data * self.basis_transform

    def super_from_tm(self, tm):
        """
        Reconstruct a super operator from a transfer matrix representation.
        This inverts `self.transfer_matrix(...)`.

        :param (numpy.ndarray) tm: A process in transfer matrix form.
        :return: A qutip super operator.
        :rtype: qutip.Qobj.
        """
        if not self.is_orthonormal():  # pragma no coverage
            raise ValueError("super_from_tm() only implemented for orthonormal operator bases")

        data = self.basis_transform * tm * self.basis_transform.H
        sop = qt.Qobj(data, dims=[self.ops[0].dims, self.ops[0].dims])
        sop.superrep = "super"
        return sop

    def __str__(self):
        return "<span[{}]>".format(",".join(self.labels))

    def __eq__(self, other):
        return (self.labels == other.labels and all(
            [(my_op - o_op).norm('fro') < EPS for (my_op, o_op) in zip(self.ops, other.ops)]))


PAULI_BASIS = OperatorBasis(
    [("I", qI / np.sqrt(2)), ("X", qX / np.sqrt(2)), ("Y", qY / np.sqrt(2)), ("Z", qZ / np.sqrt(2))])


def gell_mann_basis(qudit_dim):
    """
    Compute an orthonormal hermitian operator basis for the space of observables of a qudit with
    `d` levels. These are identical to the Gell-Mann matrices up to normalization.
    See also this
    `wikipedia article <https://en.wikipedia.org/wiki/Generalizations_of_Pauli_matrices>`_ .

    :param int qudit_dim: The dimension of the underlying Hilbert space.
    :return: The normalized Gell-Mann operator basis.
    :rtype: OperatorBasis
    """

    labels_ops = [('I', qt.qeye(qudit_dim) / np.sqrt(qudit_dim))]
    xops = []
    yops = []

    # off diagonals
    for jj in range(qudit_dim):
        for kk in range(jj):
            sigma_jk = qt.projection(qudit_dim, jj, kk)
            xops.append(('X{}{}'.format(kk, jj), (sigma_jk + sigma_jk.dag()) / np.sqrt(2)))
            yops.append(('Y{}{}'.format(kk, jj), (sigma_jk - sigma_jk.dag()) / np.sqrt(2) * 1j))

    labels_ops += xops + yops

    # diagonals
    for jj in range(1, qudit_dim):
        diag = np.array([1.] * jj + [-jj] + [0.] * (qudit_dim - jj - 1))
        diag /= np.linalg.norm(diag, 2)
        labels_ops.append(('Z{}'.format(jj),
                           qt.qdiags([diag], [0], [[qudit_dim], [qudit_dim]],
                                     (qudit_dim, qudit_dim))))

    return OperatorBasis(labels_ops)


def n_qubit_pauli_basis(n):
    """
    Construct the tensor product operator basis of `n` PAULI_BASIS's.

    :param int n: The number of qubits.
    :return OperatorBasis: The product Pauli operator basis of `n` qubits
    """
    if n >= 1:
        return PAULI_BASIS ** n
    else:  # pragma no coverage
        raise ValueError("n = {} should be at least 1.".format(n))


def n_qubit_ground_state(n):
    """
    Construct the tensor product of `n` ground states |0>.

    :param int n: The number of qubits.
    :return qutip.Qobj: The state |000...0> for `n` qubits.
    """
    return qt.tensor(*([GS] * n))


def to_density_matrix(state):
    """
    Convert a Hilbert space vector to a density matrix.
    """
    return state * state.dag()


GS = to_density_matrix(qt.basis(2, 0))
ES = to_density_matrix(qt.basis(2, 1))


def generated_states(initial_state, preparations):
    """
    Generate states prepared from channel operators acting on an initial state.
    Typically the channel operators will be unitary.

    :param qutip.Qobj initial_state: The initial state as a density matrix.
    :param (list|tuple) preparations: The unitary channel operators that transform the initial state.
    """
    return [e * initial_state * e.dag() for e in preparations]


def is_hermitian(operator):
    """
    Check if matrix or operator is hermitian.

    :param (numpy.ndarray|qutip.Qobj) operator: The operator or matrix to be tested.
    :return: True if the operator is hermitian.
    :rtype: bool
    """
    if isinstance(operator, qt.Qobj):
        return (operator.dag() - operator).norm('fro') / operator.norm('fro') < EPS
    if isinstance(operator, np.ndarray):
        return np.linalg.norm(operator.T.conj() - operator) / np.linalg.norm(operator) < EPS
    return spnorm(operator.H - operator) / spnorm(operator) < EPS


def is_projector(operator):
    """
    Check if operator is a projector.

    :param qutip.Qobj operator: The operator or matrix to be tested.
    :return: True if the operator is a projector.
    :rtype: bool
    """
    # verify that P^dag=P and P^2-P=0 holds up to relative numerical accuracy EPS.
    return (is_hermitian(operator) and (operator * operator - operator).norm('fro') / operator.norm(
        'fro') < EPS)


def choi_matrix(pauli_tm, basis):
    """
    Compute the Choi matrix for a quantum process from its Pauli Transfer Matrix.

    This agrees with the definition in [Chow]_ except for a different overall normalization.
    Our normalization agrees with that of qutip.

    .. [Chow] Chow et al., 2012, https://doi.org/10.1103/PhysRevLett.109.060501

    :param numpy.ndarray pauli_tm: The Pauli Transfer Matrix as 2d-array.
    :param OperatorBasis basis:  The operator basis, typically products of normalized Paulis.
    :return qutip.Qobj: The Choi matrix as qutip.Qobj.
    """

    if not basis.is_orthonormal():  # pragma no coverage
        raise ValueError("Need an orthonormal operator basis.")
    if not all((is_hermitian(op) for op in basis.ops)):  # pragma no coverage
        raise ValueError("Need an operator basis of hermitian operators.")

    sbasis = basis.super_basis()
    D = basis.dim
    choi = sum((pauli_tm[jj, kk] * sbasis.ops[jj + kk * D] for jj in range(D) for kk in range(D)))
    choi.superrep = "choi"
    return choi


def to_realimag(Z):
    """
    Convert a complex hermitian matrix to a real valued doubled up representation, i.e., for
    ``Z = Z_r + 1j * Z_i`` return ``R(Z)``::

        R(Z) = [ Z_r   Z_i]
               [-Z_i   Z_r]

    A complex hermitian matrix ``Z`` with elementwise real and imaginary parts
    ``Z = Z_r + 1j * Z_i`` can be
    isomorphically represented in doubled up form as::

        R(Z) = [ Z_r   Z_i]
               [-Z_i   Z_r]

        R(X)*R(Y) = [ (X_r*Y_r-X_i*Y_i)    (X_r*Y_i + X_i*Y_r)]
                    [-(X_r*Y_i + X_i*Y_r)  (X_r*Y_r-X_i*Y_i)  ]

                  = R(X*Y).

    In particular, ``Z`` is complex positive (semi-)definite iff ``R(Z)`` is real positive
    (semi-)definite.

    :param (qutip.Qobj|scipy.sparse.base.spmatrix) Z:  The operator representation matrix.
    :returns: R(Z) the doubled up representation.
    :rtype: scipy.sparse.csr_matrix
    """
    if isinstance(Z, qt.Qobj):
        Z = Z.data
    if not is_hermitian(Z):  # pragma no coverage
        raise ValueError("Need a hermitian matrix Z")
    return spvstack([sphstack([Z.real, Z.imag]), sphstack([Z.imag.T, Z.real])]).tocsr()


def matrix_histogram_complex(M, xlabels=None, ylabels=None,
                             title=None, limits=None, phase_limits=None,
                             colorbar=True, fig=None, ax=None,
                             threshold=None):
    """
    Ported from qt.matrix_histogram_complex so that colors may be modified. See
    http://qutip.org/docs/3.1.0/apidoc/functions.html#qutip.visualization.matrix_histogram_complex

    Original docs:
    Draw a histogram for the amplitudes of matrix M, using the argument
    of each element for coloring the bars, with the given x and y labels
    and title.

    Parameters
    ----------
    M : Matrix of Qobj
        The matrix to visualize

    xlabels : list of strings
        list of x labels

    ylabels : list of strings
        list of y labels

    title : string
        title of the plot (optional)

    limits : list/array with two float numbers
        The z-axis limits [min, max] (optional)

    phase_limits : list/array with two float numbers
        The phase-axis (colorbar) limits [min, max] (optional)

    ax : a matplotlib axes instance
        The axes context in which the plot will be drawn.

    threshold: float (None)
        Threshold for when bars of smaller height should be transparent. If
        not set, all bars are colored according to the color map.

    Returns
    -------
    fig, ax : tuple
        A tuple of the matplotlib figure and axes instances used to produce
        the figure.

    Raises
    ------
    ValueError
        Input argument is not valid.

    """

    if isinstance(M, qt.Qobj):
        # extract matrix data from Qobj
        M = M.full()

    n = np.size(M)
    xpos, ypos = np.meshgrid(range(M.shape[0]), range(M.shape[1]))
    xpos = xpos.T.flatten() - 0.5
    ypos = ypos.T.flatten() - 0.5
    zpos = np.zeros(n)
    dx = dy = 0.8 * np.ones(n)
    Mvec = M.flatten()
    dz = abs(Mvec)

    # make small numbers real, to avoid random colors
    idx, = np.where(abs(Mvec) < 0.001)
    Mvec[idx] = abs(Mvec[idx])

    if phase_limits:  # check that limits is a list type
        phase_min = phase_limits[0]
        phase_max = phase_limits[1]
    else:
        phase_min = -np.pi
        phase_max = np.pi

    norm = mpl.colors.Normalize(phase_min, phase_max)
    cmap = rigetti_4_color_cm

    colors = cmap(norm(np.angle(Mvec)))
    if threshold is not None:
        colors[:, 3] = 1 * (dz > threshold)

    if ax is None:
        fig = plt.figure()
        ax = Axes3D(fig, azim=-35, elev=35)

    ax.bar3d(xpos, ypos, zpos, dx, dy, dz, color=colors)

    # TODO: Set title font size
    if title and fig:
        ax.set_title(title)

    # x axis
    # TODO: Set xlabel font size
    ax.axes.w_xaxis.set_major_locator(plt.IndexLocator(1, -0.5))
    if xlabels:
        ax.set_xticklabels(xlabels)
    ax.tick_params(axis='x', labelsize=12)

    # y axis
    # TODO: Set ylabel font size
    ax.axes.w_yaxis.set_major_locator(plt.IndexLocator(1, -0.5))
    if ylabels:
        ax.set_yticklabels(ylabels)
    ax.tick_params(axis='y', labelsize=12)

    # z axis
    # TODO: Set zlabel font size
    if limits and isinstance(limits, list):
        ax.set_zlim3d(limits)
    else:
        ax.set_zlim3d([0, 1])  # use min/max
    # ax.set_zlabel('abs')

    # color axis
    if colorbar:
        cax, kw = mpl.colorbar.make_axes(ax, shrink=.75, pad=.0)
        cb = mpl.colorbar.ColorbarBase(cax, cmap=cmap, norm=norm)
        cb.set_ticks([-np.pi, -np.pi / 2, 0, np.pi / 2, np.pi])
        cb.set_ticklabels(
            (r'$-\pi$', r'$-\pi/2$', r'$0$', r'$\pi/2$', r'$\pi$'))
        cb.set_label('arg')

    return fig, ax


# using the Z-basis for POVM terms allows to easily identify multi-body contributions
# Z_i Z_j ... Z_k to the readout signal. This should lead to sparsity vs the readout signal index
POVM_Z_BASIS = OperatorBasis([("I", qI), ("Z", qZ)])


# using the Pi-basis for POVM terms allows to easily associate the preparations with individual
# multi-qubit projectors
POVM_PI_BASIS = OperatorBasis([("0", GS), ("1", ES)])
